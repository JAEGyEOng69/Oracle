CREATE TABLE BOOK(
    BOOK_ID NUMBER NOT NULL,
    TITLE VARCHAR2(600) NOT NULL,
    CATEGORY VARCHAR2(600) NOT NULL,
    PRICE NUMBER,
    INSERT_DATE DATE,
    CONSTRAINT PK_BOOK PRIMARY KEY(BOOK_ID)
    
);

COMMENT ON TABLE BOOK IS '도서정보';
COMMENT ON COLUMN BOOK.BOOK_ID IS '도서 코드';
COMMENT ON COLUMN BOOK.TITLE IS '제목';
COMMENT ON COLUMN BOOK.CATEGORY IS '카테고리';
COMMENT ON COLUMN BOOK.PRICE IS '가격';
COMMENT ON COLUMN BOOK.INSERT_DATE IS '입력일자';

SELECT *
FROM BOOK;




/
create or replace FUNCTION FN_GETCAMEL(COLUMN_NAME IN VARCHAR2)
RETURN VARCHAR2
IS
RSLT VARCHAR2(30);
BEGIN
--카멜표기로 변환(SITE_NUM -> siteNum)
SELECT LOWER(SUBSTR(REPLACE(INITCAP(COLUMN_NAME),'_'),1,1))
|| SUBSTR(REPLACE(INITCAP(COLUMN_NAME),'_'),2) INTO RSLT
FROM DUAL;
--리턴
RETURN RSLT;
END;
/

--구글 카멜변환(https://heavenly-appear.tistory.com/270)
/
SELECT COLUMN_NAME
, DATA_TYPE
, CASE WHEN DATA_TYPE='NUMBER' THEN 'private int ' || FN_GETCAMEL(COLUMN_NAME) || ';'
WHEN DATA_TYPE IN('VARCHAR2','CHAR') THEN 'private String ' || FN_GETCAMEL(COLUMN_NAME) || ';'
WHEN DATA_TYPE='DATE' THEN 'private Date ' || FN_GETCAMEL(COLUMN_NAME) || ';'
ELSE 'private String ' || FN_GETCAMEL(COLUMN_NAME) || ';'
END AS CAMEL_CASE
, '' RESULTMAP
FROM ALL_TAB_COLUMNS
WHERE TABLE_NAME = 'INSURERE';
/
INSERT INTO BOOK(BOOK_ID, TITLE, CATEGORY, PRICE, INSERT_DATE) VALUES(1, '개똥이 월드', '소설', 10000, SYSDATE);
SELECT * FROM BOOK;

SELECT NVL(MAX(BOOK_ID),0)+1 FROM BOOK;



--==================================== PRODUCT =================================================================================
CREATE TABLE PRODUCT(
    BOOK_ID NUMBER NOT NULL,
    TITLE VARCHAR2(600) NOT NULL,
    CATEGORY VARCHAR2(600) NOT NULL,
    PRICE NUMBER,
    INSERT_DATE DATE,
    CONSTRAINT PK_BOOK PRIMARY KEY(BOOK_ID)
    
);

COMMENT ON TABLE BOOK IS '도서정보';
COMMENT ON COLUMN BOOK.BOOK_ID IS '도서 코드';
COMMENT ON COLUMN BOOK.TITLE IS '제목';
COMMENT ON COLUMN BOOK.CATEGORY IS '카테고리';
COMMENT ON COLUMN BOOK.PRICE IS '가격';
COMMENT ON COLUMN BOOK.INSERT_DATE IS '입력일자';

SELECT *
FROM BOOK;

INSERT INTO VALUES();


/
create or replace FUNCTION FN_GETCAMEL(COLUMN_NAME IN VARCHAR2)
RETURN VARCHAR2
IS
RSLT VARCHAR2(30);
BEGIN
--카멜표기로 변환(SITE_NUM -> siteNum)
SELECT LOWER(SUBSTR(REPLACE(INITCAP(COLUMN_NAME),'_'),1,1))
|| SUBSTR(REPLACE(INITCAP(COLUMN_NAME),'_'),2) INTO RSLT
FROM DUAL;
--리턴
RETURN RSLT;
END;
/

--구글 카멜변환(https://heavenly-appear.tistory.com/270)
SELECT COLUMN_NAME
, DATA_TYPE
, CASE WHEN DATA_TYPE='NUMBER' THEN 'private int ' || FN_GETCAMEL(COLUMN_NAME) || ';'
WHEN DATA_TYPE IN('VARCHAR2','CHAR') THEN 'private String ' || FN_GETCAMEL(COLUMN_NAME) || ';'
WHEN DATA_TYPE='DATE' THEN 'private Date ' || FN_GETCAMEL(COLUMN_NAME) || ';'
ELSE 'private String ' || FN_GETCAMEL(COLUMN_NAME) || ';'
END AS CAMEL_CASE
, '' RESULTMAP
FROM ALL_TAB_COLUMNS
WHERE TABLE_NAME = 'CERTIFICATE_ORDER';

INSERT INTO BOOK(BOOK_ID, TITLE, CATEGORY, PRICE, INSERT_DATE) VALUES(1, '개똥이 월드', '소설', 10000, SYSDATE);
SELECT * FROM BOOK;

SELECT NVL(MAX(BOOK_ID),0)+1 FROM BOOK;

INSERT INTO PRODUCT(PRODUCT_ID,PNAME,UNIT_PRICE,DESCRIPTION,MANUFACTURER,CATEGORY,UNITS_IN_STOCK,CONDITION) VALUES('1','1','1','1','1','1','1','1')
SELECT * FROM PRODUCT


SELECT BOOK_ID, TITLE, CATEGORY, PRICE, INSERT_DATE
FROM BOOK
ORDER BY INSERT_DATE DESC;

UPDATE BOOK
SET    TITLE='개똥이모험', CATEGORY='판타지', PRICE=12000
WHERE BOOK_ID=1;
commit;
rollback;

DELETE 
FROM BOOK
WHERE BOOK_ID=9;


SELECT PRODUCT_ID,PNAME,UNIT_PRICE,DESCRIPTION,MANUFACTURER,CATEGORY,UNITS_IN_STOCK,CONDITION
FROM PRODUCT
WHERE PRODUCT_ID ='P1235';

UPDATE PRODUCT
SET   PNAME='1',UNIT_PRICE='1',DESCRIPTION='1',MANUFACTURER='1',CATEGORY='1',UNITS_IN_STOCK='1',CONDITION='1'
WHERE product_id ='P1234';
commit;
rollback;

DELETE 
FROM PRODUCT
WHERE PRODUCT_ID='P1235'


DROP TABLE PRODUCT;

SQL>INSERT INTO book
    (SELECT * FROM emp AS OF TIMESTAMP TO_TIMESTAMP('2006-01-21 17:16:51', 'YYYY-MM-DD HH24:MI:SS'));
    
Insert into JSPEXAM.PRODUCT (PRODUCT_ID,PNAME,UNIT_PRICE,DESCRIPTION,MANUFACTURER,CATEGORY,UNITS_IN_STOCK,CONDITION,FILENAME) values ('P1234','iPhone 6s',800000,'4.7-inch, 1334X750 Renina HD display','Smart Phone','Apple',1000,'New','P1234.jpg');
Insert into JSPEXAM.PRODUCT (PRODUCT_ID,PNAME,UNIT_PRICE,DESCRIPTION,MANUFACTURER,CATEGORY,UNITS_IN_STOCK,CONDITION,FILENAME) values ('P1235','LG PC 그램',1500000,'13.3-inch, IPS LED display','Notebook','LG',1000,'Refurbished','P1235.jpg');
Insert into JSPEXAM.PRODUCT (PRODUCT_ID,PNAME,UNIT_PRICE,DESCRIPTION,MANUFACTURER,CATEGORY,UNITS_IN_STOCK,CONDITION,FILENAME) values ('P1236','Galaxy Tab S',920000,'212.8*125.6*6.6mm, Super AMOLED display','Tablet','Samsung',2000,'Refurbished','P1236.jpg');
Insert into JSPEXAM.PRODUCT (PRODUCT_ID,PNAME,UNIT_PRICE,DESCRIPTION,MANUFACTURER,CATEGORY,UNITS_IN_STOCK,CONDITION,FILENAME) values ('P123456','애플핸드폰',10000,'애플핸드폰','애플핸드폰','애플핸드폰',0,'Old','P1237.jpg');

INSERT INTO CART(CART_ID, NAME, SHIPPING_DATE, COUNTRY, ZIP_CODE, ADDRESS_NAME, ADDRESS_DETAIL, REGIST_DT) VALUES()

CREATE TABLE BOOK_MARKET(
    BOOK_ID   VARCHAR2(20) NOT NULL,
    NAME   VARCHAR2(150) NOT NULL,
    UNIT_PRICE   NUMBER  NOT NULL,
    AUTHOR  VARCHAR2(150),
    DESCRIPTION   VARCHAR2(1000),
    PUBLISHER   VARCHAR2(60),
    CATEGORY   VARCHAR2(90) NOT NULL,
    UNITS_IN_STOCK   NUMBER,
    TOTAL_PAGES  NUMBER,
    RELEASE_DATE VARCHAR2(30),
    CONDITION   VARCHAR2(30),
    FILENAME   VARCHAR2(1000),
    QUANTITY   NUMBER,
    CONSTRAINT PK_BOOK_MARKET PRIMARY KEY(BOOK_ID)
);
    
    
    CONSTRAINT PK_BOOK PRIMARY KEY(BOOK_ID)
    
);

COMMENT ON TABLE BOOK_MARKET IS '도서정보';
COMMENT ON COLUMN BOOK_MARKET.BOOK_ID IS '도서 코드';
COMMENT ON COLUMN BOOK_MARKET.NAME IS '도서명';
COMMENT ON COLUMN BOOK_MARKET.UNIT_PIRCE IS '가격';
COMMENT ON COLUMN BOOK_MARKET.AUTHOR IS '저자';
COMMENT ON COLUMN BOOK_MARKET.DESCRIPTION IS '설명';
COMMENT ON COLUMN BOOK_MARKET.PUBLISHER IS '출판사';
COMMENT ON COLUMN BOOK_MARKET.CATEGORY IS '카테고리';
COMMENT ON COLUMN BOOK_MARKET.UNITS_IN_STOCK IS '재고 수';
COMMENT ON COLUMN BOOK_MARKET.TOTAL_PAGES IS '페이지 수';
COMMENT ON COLUMN BOOK_MARKET.RELEASE_DATE IS '출판일';
COMMENT ON COLUMN BOOK_MARKET.CONDITION IS '상태';
COMMENT ON COLUMN BOOK_MARKET.FILENAME IS '파일명';
COMMENT ON COLUMN BOOK_MARKET.QUANTITY IS '수량';

CREATE TABLE ITEM(
    ITEM_ID NUMBER,
    ITEM_NAME VARCHAR2(150),
    PRICE NUMBER,
    DESCRIPTION VARCHAR2(300),
    PICTURE_URL VARCHAR2(300),
    CONSTRAINT PK_ITEM PRIMARY KEY(ITEM_ID)
);

CREATE TABLE ITEM2(
    ITEM_ID NUMBER,
    ITEM_NAME VARCHAR2(150),
    PRICE NUMBER,
    DESCRIPTION VARCHAR2(300),
    PICTURE_URL VARCHAR2(300),
    PICTURE_URL2 VARCHAR2(300),
    CONSTRAINT PK_ITEM2 PRIMARY KEY(ITEM_ID)
);
CREATE TABLE ITEM3(
    ITEM_ID NUMBER,
    ITEM_NAME VARCHAR2(150),
    PRICE NUMBER,
    DESCRIPTION VARCHAR2(300),
    CONSTRAINT PK_ITEM3 PRIMARY KEY(ITEM_ID)
);

CREATE TABLE ITEM_ATTACH(
    SEQ NUMBER,
    ITEM_ID NUMBER,
    FULLNAME VARCHAR2(300),
    REGDATE DATE,
    CONSTRAINT PK_ITEM_ATTACH PRIMARY KEY(SEQ)
);

COMMENT ON TABLE ITEM2 IS '상품2';
COMMENT ON COLUMN ITEM2.ITEM_ID IS '상품 아이디';
COMMENT ON COLUMN ITEM2.ITEM_NAME IS '상품 명';
COMMENT ON COLUMN ITEM2.PRICE IS '가격';
COMMENT ON COLUMN ITEM2.DESCRIPTION IS '설명';
COMMENT ON COLUMN ITEM2.PICTURE_URL IS '상품 이미지1';
COMMENT ON COLUMN ITEM2.PICTURE_URL2 IS '상품 이미지2';

CREATE TABLE ATTACH(
    SEQ NUMBER,
    TID VARCHAR2(30),
    NAME VARCHAR2(300),
    ATTACH_SIZE NUMBER,
    ATTACH_TYPE VARCHAR2(30),
    REGIST_DATE DATE,
    CONSTRAINT PK_ATTACH PRIMARY KEY(SEQ)
);

INSERT ALL
INTO ATTACH VALUES(1, 'P1238', '1', 2, 'jpeg', sysdate)
INTO ATTACH VALUES(2, 'P1238', '2', 2, 'jpeg', sysdate)
INTO ATTACH VALUES(3, 'P1238', '3', 2, 'jpeg', sysdate)
SELECT * FROM SYS.DUAL;

INSERT INTO BOOK_MARKET(BOOK_ID, NAME, UNIT_PRICE, AUTHOR, DESCRIPTION, PUBLISHER, CATEGORY, UNITS_IN_STOCK, TOTAL_PAGES, RELEASE_DATE, CONDITION, FILENAME, QUANTITY) 
VALUES('B1233'	,'C++',	44850	,'오호식',	'C++한달만에 하기 특별하깅',	'JJAn','C++', 93,399,	'2021-11-11','NEW',	'B1233.png',84);

INSERT INTO BOOK_MARKET(BOOK_ID, NAME, UNIT_PRICE, AUTHOR, DESCRIPTION, PUBLISHER, CATEGORY, UNITS_IN_STOCK, TOTAL_PAGES, RELEASE_DATE, CONDITION, FILENAME, QUANTITY) 
VALUES('B1234'	,'걷기의 재발견',	24850	,'오개식',	'걷기는 최고 건강 관리 화이팅',	'ohoh','걷기', 65,890,	'2022-11-08','NEW',	'B1234.png',94);

SELECT BOOK_ID, NAME, UNIT_PRICE, AUTHOR, DESCRIPTION, PUBLISHER, CATEGORY, UNITS_IN_STOCK, TOTAL_PAGES, RELEASE_DATE, CONDITION, FILENAME, QUANTITY
FROM BOOK_MARKET;
WHERE 1 = 1
AND   BOOK_ID LIKE '%' || #{keyWord} || '%' 
OR 	  CATEGORY LIKE '%' || #{keyWord} || '%'
ORDER BY INSERT_DATE DESC

--LEFT JOIN
SELECT P.PRODUCT_ID,P.PNAME, P.UNIT_PRICE, P.DESCRIPTION, P.MANUFACTURER, P.CATEGORY, P.UNITS_IN_STOCK, P.CONDITION, P.FILENAME, A.ATTACH_NAME
FROM PRODUCT P, ATTACH A
WHERE P.PRODUCT_ID = A.TID(+)
AND    P.PRODUCT_ID = 'P1237'
AND A.SEQ=1;

-- 서브쿼리
SELECT P.PRODUCT_ID,P.PNAME
, P.UNIT_PRICE
, P.DESCRIPTION
, P.MANUFACTURER
, P.CATEGORY
, P.UNITS_IN_STOCK
, P.CONDITION
, (SELECT A.ATTACH_NAME FROM ATTACH A 
    WHERE P.PRODUCT_ID = A.TID
    AND A.SEQ = 1) FILENAME
FROM PRODUCT P
WHERE P.PRODUCT_ID ='P1238';

INSERT INTO MEMBER(USER_ID,PASSWORD,COIN,BIRTH,GENDER,NATIONALITY,MARRIAGED,CARS,HOBBY_LIST)
VALUES('a001','java',100,'2022-11-01','male','korea','false','gm6,volvo','moovie,book');

INSERT INTO ADDRESS(USER_ID, POST_CODE, ADDRESS, ADDRESS_DETAIL)
VALUES('a001','12345','대전 중구 중앙로12','개똥이 빌딩');

INSERT INTO CARD(USER_ID, NO, VALID_MONTH) 
VALUES('a001',
(SELECT NVL(MAX(NO),0)+1 FROM CARD WHERE USER_ID='a001'), '2022-11-01');

INSERT INTO CARD(USER_ID, NO, VALID_MONTH) 
VALUES('a001','12346','2022-11-01');

WITH T AS(
SELECT  ROW_NUMBER() OVER (ORDER BY MEM_ID) RNUM,
		MEM_ID,
		MEM_NAME,
		MEM_HP,
		MEM_JOB,
		MEM_LIKE
		FROM
		MEM
        WHERE 1=1
        AND (MEM_ID LIKE '%01%' 
        OR MEM_NAME LIKE '%01%'
        OR MEM_HP   LIKE '%01%'
        OR MEM_JOB  LIKE '%01%'
        OR MEM_LIKE LIKE '%01%')
)
SELECT COUNT(*) FROM MEM
WHERE MEM_ID = 'a001'

SELECT * FROM T
WHERE T.RNUM BETWEEN 1 * 10 -9  AND 1 * 10;
DECLARE
BEGIN
    FOR I IN 101..355 LOOP
    INSERT INTO MEM(MEM_ID, MEM_NAME, MEM_HP, MEM_JOB, MEM_LIKE) 
    VALUES('z'||TRIM(TO_CHAR(I,'000')),	'김은태'||TRIM(TO_CHAR(I,'000')),'010-621-4615',	'농부','잠자기');
    END LOOP;
END;
/
SELECT TO_CHAR(2,'100') FROM DUAL;

SELECT COUNT(*) FROM MEM;

CREATE TABLE CHATTING_USER(
    NO NUMBER NOT NULL,
    USER_ID VARCHAR2(600) NOT NULL,
    PASSWORD VARCHAR2(600) NOT NULL,
    NAME VARCHAR2(600) 
);
DROP TABLE CHATTING_USER;

CREATE TABLE BOM(
    ITEM_ID NUMBER,
    PARENT_ID NUMBER,
    ITEM_NAME VARCHAR2(150),
    ITEM_QTY NUMBER,
    CONSTRAINT PK_BOM PRIMARY KEY(ITEM_ID)
);
COMMENT ON TABLE BOM IS '컴퓨터 구성 정보';
COMMENT ON COLUMN BOM.ITEM_ID IS '품목 식별자';
COMMENT ON COLUMN BOM.PARENT_ID IS '상위 품목 식별자';
COMMENT ON COLUMN BOM.ITEM_NAME IS '품목 이름';
COMMENT ON COLUMN BOM.ITEM_QTY IS '품목 개수';


INSERT INTO BOM VALUES ( 1001, NULL, '컴퓨터', 1);
INSERT INTO BOM VALUES ( 1002, 1001, '본체', 1);
INSERT INTO BOM VALUES ( 1003, 1001, '모니터', 1);
INSERT INTO BOM VALUES ( 1004, 1001, '프린터', 1);

INSERT INTO BOM VALUES ( 1005, 1002, '메인보드', 1);
INSERT INTO BOM VALUES ( 1006, 1002, '랜카드', 1);
INSERT INTO BOM VALUES ( 1007, 1002, '파워서플라이', 1);
INSERT INTO BOM VALUES ( 1008, 1005, 'CPU', 1);
INSERT INTO BOM VALUES ( 1009, 1005, 'RAM', 1);
INSERT INTO BOM VALUES ( 1010, 1005, '그래픽카드', 1);
INSERT INTO BOM VALUES ( 1011, 1005, '기타',1);

SELECT ITEM_NAME
,       ITEM_ID
,       PARENT_ID
FROM BOM
START WITH PARENT_ID IS NULL
CONNECT BY PRIOR ITEM_ID = PARENT_ID;

CREATE TABLE AMUMAL(
    NO NUMBER,
    TITLE VARCHAR2(90),
    WRITER VARCHAR2(60),
    PNO NUMBER,
    CONSTRAINT PK_AMUMAL PRIMARY KEY (NO)
);

INSERT INTO AMUMAL VALUES(1,'여름은 더워','홍길동',NULL);   
INSERT INTO AMUMAL VALUES(2,'맞아 더워','김철수',1);   
INSERT INTO AMUMAL VALUES(3,'그래서 여름이지','홍길동',1);   
INSERT INTO AMUMAL VALUES(4,'정말 그래','노홍철',3);   
INSERT INTO AMUMAL VALUES(5,'그래 정말','지상철',4);   
INSERT INTO AMUMAL VALUES(6,'말장난 하지마','노홍철',4);   
INSERT INTO AMUMAL VALUES(7,'말장난 좋은걸','지상철',4);   
INSERT INTO AMUMAL VALUES(8,'그러게','하정우',3);   
INSERT INTO AMUMAL VALUES(9,'가을아 와라','김진수',3);   
INSERT INTO AMUMAL VALUES(10,'그래도 여름이 좋아','박명수',1);   

SELECT NO
     , LPAD('ㄴ',2*(LEVEL-1)) || TITLE AS TITLE
     , WRITER
     , PNO 
FROM   AMUMAL
START WITH PNO IS NULL
CONNECT BY PRIOR NO = PNO;

SELECT M.MEM_ID, M.MEM_NAME, M.MEM_HP, M.MEM_JOB, M.MEM_LIKE, A.SEQ, A.TID, A.ATTACH_NAME
FROM MEM M LEFT OUTER JOIN  ATTACH A ON(M.MEM_ID =A.TID)
WHERE M.MEM_ID='a001';

ROLLBACK;

INSERT INTO MEM(USER_NO, USER_ID, USER_PW, USER_NAME, USER_EMAIL, 
                    UPD_DATE)
VALUES();

INSERT ALL ATTACH
INTO ATTACH VALUES(4, 'a001', 'attach01',0,'image/png',SYSDATE)
INTO ATTACH VALUES(5, 'a001', 'attach01',0,'image/png',SYSDATE)
SELECT * FROM DUAL;

SELECT MAX(SEQ+1 FROM ATTACH
WHERE TID='a001';

VALUES()



-- 오늘 연월+001
SELECT TO_CHAR(SYSDATE, 'YYYYMM') + '001' FROM DUAL;

-- 오늘 연월에 해당하는 MEM 데이터가 있는지?
SELECT NVL(MAX(USER_NO), TO_CHAR(SYSDATE, 'YYYYMM"000"')) +1 FROM MEM
WHERE TO_CHAR(SYSDATE, 'YYYYMM') = SUBSTR(USER_NO, 1,6);

CREATE TABLE MEM_BAK
AS
SELECT *
FROM MEM;
DROP TABLE MEM;

CREATE TABLE MEM(
    USER_NO NUMBER,
    USER_ID VARCHAR2(30),
    USER_PW VARCHAR2(150),
    USER_NAME VARCHAR2(150),
    USER_EMAIL VARCHAR2(50),
    COIN NUMBER,
    REG_DATE DATE,
    UPD_DATE DATE,
    ENABLED VARCHAR2(10),
    FILENAME VARCHAR2(500),
    CONSTRAINT PK_MEM PRIMARY KEY(USER_NO)
);

CREATE TABLE ATTACH_BAK
AS
SELECT * FROM ATTACH;

DROP TABLE ATTACH;

CREATE TABLE ATTACH(
    USER_NO NUMBER,
    SEQ NUMBER,
    FILENAME VARCHAR2(100),
    FILESIZE NUMBER,
    REGDATE DATE,
    CONSTRAINT PK_ATTACH PRIMARY KEY(USER_NO, SEQ)
);
SELECT A.USER_NO , A.SEQ, A.FILENAME,
        M.USER_NO, M.USER_ID, M.USER_NAME
FROM MEM M LEFT OUTER JOIN  ATTACH A ON(M.USER_NO = A.USER_NO)
WHERE M.USER_ID='a001';

-- 자료형과 크기가 같으면 외래키 제약 설정이 가능하고 
-- 자료형이 같으면 조인이 가능 
SELECT M.USER_NO, M.USER_ID, M.USER_PW, M.USER_NAME, M.USER_EMAIL
     , M.COIN, M.REG_DATE, M.UPD_DATE, M.ENABLED
     , A.FILENAME
FROM   MEM M, ATTACH A
WHERE  M.USER_ID = A.USER_NO
AND    M.USER_NO = '202211001';

SELECT M.USER_NO, M.USER_ID, M.USER_NAME, A.SEQ, A.FILENAME
		FROM   MEM M LEFT OUTER JOIN ATTACH A ON(M.USER_ID = A.USER_NO);

SELECT COUNT(*)
FROM MEM
WHERE USER_NO = '202211001' AND USER_PW = '1234';

SELECT M.USER_NO, M.USER_ID, M.USER_PW, M.USER_NAME, M.USER_EMAIL
	     , M.COIN, M.REG_DATE, M.UPD_DATE, M.ENABLED
	     , A.FILENAME
		FROM   MEM M, ATTACH A
		WHERE  M.USER_ID = A.USER_NO
		AND    M.USER_NO ='202211005';

-- 업데이트 
UPDATE MEM
SET USER_NAME ='김철수', USER_EMAIL='test@test.com', UPD_DATE=SYSDATE 
WHERE USER_NO ='202211005';
rollback
commit;

DELETE 
FROM MEM
WHERE USER_NO='202211002';

ALTER TABLE ATTACH 
ADD (ATTACH_NAME VARCHAR2(300),
    ATTACH_SIZE NUMBER, 
    ATTACH_TYPE VARCHAR2(30)
    );
    
CREATE TABLE USERS(
    USERNAME VARCHAR2(150),
    PASSWORD VARCHAR2(150),
    ENABLED VARCHAR2(1),
    CONSTRAINT PK_USERS PRIMARY KEY(USERNAME)
);    
    
COMMENT ON TABLE USERS IS '사용자 관리 테이블';
COMMENT ON COLUMN USERS.USERNAME IS '아이디';
COMMENT ON COLUMN USERS.PASSWORD IS '비밀번호';
COMMENT ON COLUMN USERS.ENABLED IS '사용여부';

CREATE TABLE AUTHORITIES(
    USERNAME VARCHAR2(150),
    AUTHORITY VARCHAR2(150),
    CONSTRAINT PK_AUTHORITIES PRIMARY KEY(USERNAME),
    CONSTRAINT FK_AUTHORITIES FOREIGN KEY(USERNAME)
            REFERENCES USERS(USERNAME)
);
rollback
COMMENT ON TABLE AUTHORITIES IS '사용자 권한 정보';
COMMENT ON COLUMN AUTHORITIES.USERNAME IS '아이디';
COMMENT ON COLUMN AUTHORITIES.AUTHORITY IS '권한';

INSERT INTO USERS(USERNAME, PASSWORD) VALUES('user00', '1234');
INSERT INTO USERS(USERNAME, PASSWORD) VALUES('member00', '1234');
INSERT INTO USERS(USERNAME, PASSWORD) VALUES('admin00', '1234');

INSERT INTO AUTHORITIES(USERNAME, AUTHORITY) VALUES('user00', 'ROLE_USER');
INSERT INTO AUTHORITIES(USERNAME, AUTHORITY) VALUES('member00', 'ROLE_MEMBER');
INSERT INTO AUTHORITIES(USERNAME, AUTHORITY) VALUES('admin00', 'ROLE_MEMBER');
INSERT INTO AUTHORITIES(USERNAME, AUTHORITY) VALUES('admin00', 'ROLE_ADMIN');


-- MEMBER 테이블을 통해 MEMBER_BAK 테이블로 복제해보자 
CREATE TABLE MEMBER_BAK
AS
SELECT * FROM MEMBER;

--MEMBER테이블 DROP 
DROP TABLE MEMBER;
DELT
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'MEMBER';

--기본키 제약사항
CREATE TABLE MEMBER
AS
SELECT * FROM MEM_BAK;

SELECT MEM_ID ,MEM_PASS, ENABLED FROM MEMBER
WHERE MEM_ID='a001';

--권한 
SELECT * 
FROM MEMBER M, MEMBER_AUTH MA
WHERE M.MEM_ID = MA.MEM_ID
AND M.MEM_ID ='a001';
--
SELECT * 
FROM MEMBER A LEFT OUTER JOIN MEMBER_AUTH AUTH ON(A.MEM_ID = AUTH.MEM_ID)
WHERE A.MEM_ID ='a001';

SELECT A.MEM_ID, 
A.MEM_NAME, 
A.MEM_HP, 
A.MEM_JOB, 
A.MEM_LIKE, 
A.MEM_PASS, 
A.ENABLED
     , AUTH.AUTH
FROM   MEMBER A LEFT OUTER JOIN MEMBER_AUTH AUTH ON(A.MEM_ID = AUTH.MEM_ID)
WHERE  A.MEM_ID = 'a001';

SELECT A.MEM_ID, 
			A.MEM_NAME, 
			A.MEM_HP, 
			A.MEM_JOB, 
			A.MEM_LIKE, 
			A.MEM_PASS, 
			A.ENABLED,
	     	AUTH.AUTH
		FROM   MEMBER A LEFT OUTER JOIN MEMBER_AUTH AUTH ON(A.MEM_ID = AUTH.MEM_ID)
		WHERE  A.MEM_ID = 'a001';
COMMIT;

CREATE TABLE PERSISTENT_LOGINS(
    USERNAME VARCHAR2(150),
    SERIES VARCHAR2(150),
    TOKEN VARCHAR2(150),
    LAST_USED DATE,
    CONSTRAINT PK_PL PRIMARY KEY(SERIES)
);

SELECT BOOK_ID, TITLE, CATEGORY, PRICE, INSERT_DATE 
FROM BOOK
ORDER BY BOOK_ID ASC;

commit;

-- VARCHAR2 : 4000Bytes 문자
--CLOB(Character Large Object) : 4GB 문자
--BLOB(Binary large Object) :2GB. 바이너리(이미지, 동영상, 음악) 
SELECT *                                    조회할 컬럼을 선택한다 (모든 컬럼 조회)
  FROM TABLE1  T1                             
  INNER JOIN TABLE2  T2              INNER 는 생략가능
  ON (T1.KEY = T2.KEY)  
-- BOOK 테이블과 ATTACH테이블을 INNER JOIN 
SELECT A.BOOK_ID, A.TITLE, A.CATEGORY, A.PRICE, A.INSERT_DATE, A.CONTENT, 
        B.USER_NO, B.SEQ, B.FILENAME, B.FILESIZE, B.REGDATE
FROM BOOK A INNER JOIN  ATTACH B ON(A.BOOK_ID = B.USER_NO);

UPDATE  ATTACH
SET     FILENAME = '/2022/11/16/ASDFLDAS_개똥이.JPG'
WHERE USER_NO = 3 AND SEQ = 5;

DELETE 
FROM ATTACH
WHERE SEQ =6;

WITH T AS(
SELECT A.BOOK_ID, A.TITLE, A.CATEGORY, A.PRICE, A.INSERT_DATE, A.CONTENT,
        B.USER_NO, B.SEQ, B.FILENAME, B.FILESIZE, B.REGDATE
FROM BOOK A LEFT OUTER JOIN ATTACH B ON(A.BOOK_ID = B.USER_No)
)
SELECT * FROM T
WHERE 1=1
AND(TITLE LIKE '%금%' OR CATEGORY LIKE '%개똥이%' OR CONTENT LIKE '%금%' );

INSERT ALL
INTO ATTACH(USER_NO, SEQ, FILENAME, FILESIZE, REGDATE) VALUES(15,1,'ASDF.JPG',200,SYSDATE)
INTO ATTACH(USER_NO, SEQ, FILENAME, FILESIZE, REGDATE) VALUES(15,2,'BSDF.JPG',300,SYSDATE)
INTO ATTACH(USER_NO, SEQ, FILENAME, FILESIZE, REGDATE) VALUES(15,3,'CSDF.JPG',100,SYSDATE)
SELECT * FROM DUAL;

SELECT NVL(MAX(SEQ),0)+1 FROM ATTACH WHERE USER_NO = 15;

CREATE TABLE CART_DET_BAK
AS
SELECT *
FROM CART_DET;

DROP TABLE CART;

drop table CART_DET cascade constraints;

--pc계정의 lprodc 테이블 데이터를 jspexam으로 가져오가ㅣ 

--상품 별 판매금액의 합계를 구해보자
--alias : prod_name, money(prod_sale * cart_qty)
--단, money 값이 10000000 이상인 데이터만 가져와보자
--1) cart 및 cart_det 테이블을 백업하고(테이블명_bak)
--      cart테이블 및 cart_det 테이블을 drop
--2) pc##계정의 prod 및 cart 테이블을 가져오자
SELECT PROD_NAME prodName, 
        SUM(PROD_SALE * CART_QTY) MONEY
FROM PROD,CART 
WHERE PROD_ID = CART_PROD
GROUP BY PROD_NAME
HAVING SUM(PROD_SALE * CART_QTY) >=10000000;

--LPROD 테이블을 LPROD2 테이블로 복제해보자 
CREATE TABLE LPROD2
AS
SELECT *
FROM LPROD;
/
SELECT * FROM LPROD2
/
MERGE INTO LPROD2 A --대상 테이블
USING DUAL
ON(A.LPROD_GU = 'P405') --조건절(주로 기본키 데이터)
WHEN MATCHED THEN --조건절에 해당하는 데이터가 있으면 실행
    UPDATE SET A.LPROD_CNT = A.LPROD_CNT + 1
WHEN NOT MATCHED THEN --조건절에 해당하는 데이터가 없으면 실행
    INSERT (LPROD_ID, LPROD_GU, LPROD_NM, LPROD_CNT)
    VALUES((SELECT NVL(MAX(LPROD_ID),0)+1 FROM LPROD2)
    ,(SELECT SUBSTR(MAX(LPROD_GU),1,1)
     || TRIM(SUBSTR(MAX(LPROD_GU),2) + 1)
    FROM   LPROD2),'가구류',0)
;
-- LPROD2 테이블의 LPROD_ID값을 1 증가시켜 리턴해주는 FUNCTION을 만들어보자
-- FUNCTION 명 : FN_NEXT_LPROD_ID 
SELECT NVL(MAX(LPROD_ID),0)+1 FROM LPROD2;
/
CREATE OR REPLACE FUNCTION FN_NEXT_LPROD_ID
RETURN NUMBER
IS
    V_ID NUMBER;
BEGIN
    --PL/SQL에서 SELECT와 함께 꼭 INTO를 쓰자
    SELECT NVL(MAX(LPROD_ID),0)+1 INTO V_ID
    FROM LPROD2;
    RETURN V_ID;
END;
/
-- LPROD2 테이블의 LPROD_GU 값을 1 증가시켜 리턴해주는 서브쿼리를 만들어보자 
-- P403 -> 1 증가 -> p405
SELECT SUBSTR(MAX(LPROD_GU),1,1)
     || TRIM(SUBSTR(MAX(LPROD_GU),2) + 1)
FROM   LPROD2;

-- 시작일자~종료일자 기간 내 모든 날짜(일자) 구하기
-- 시작일자 : 2022-12-01
-- 종료일자 : 2022-12-10
SELECT TO_DATE('2022-12-01','YYYY-MM-DD') + LEVEL - 1 AS DATES
FROM DUAL
CONNECT BY LEVEL <= (TO_DATE('2022-12-10','YYYY-MM-DD')- 
                     TO_DATE('2022-12-01','YYYY-MM-DD')+1); 
WITH DATE_RANGE AS(
    SELECT TO_DATE('2022-12-01','YYYY-MM-DD') + LEVEL - 1 AS DATES
    FROM DUAL
    CONNECT BY LEVEL <= (TO_DATE('2022-12-10','YYYY-MM-DD') - 
                         TO_DATE('2022-12-01','YYYY-MM-DD') + 1)
),
ATTENDANCE AS(
SELECT TO_DATE('2022-12-01','YYYY-MM-DD') AS ATTDATE, '출근' AS ATTSTAT FROM DUAL
UNION ALL
SELECT TO_DATE('2022-12-03','YYYY-MM-DD') AS ATTDATE, '출근' AS ATTSTAT FROM DUAL
UNION ALL
SELECT TO_DATE('2022-12-06','YYYY-MM-DD') AS ATTDATE, '출근' AS ATTSTAT FROM DUAL
)
SELECT A.DATES, B.ATTSTAT FROM DATE_RANGE A, ATTENDANCE B
WHERE  A.DATES = B.ATTDATE(+)
ORDER BY A.DATES
;

SELECT LEVEL T_NO
       , LEVEL || '교시' T_NAME
       , DECODE(LEVEL,
                1, '9:00',
                2, '10:00',
                3, '11:00',
                4, '12:00',
                5, '13:00',
                6, '14:00',
                7, '15:00',
                8, '16:00') P_SDATE
       , DECODE(LEVEL, 
                1, '9:50',
                2, '10:50',
                3, '11:50',
                4, '12:50',
                5, '13:50',
                6, '14:50',
                7, '15:50',
                8, '16:50') P_EDATE
FROM DUAL
CONNECT BY LEVEL <=8;
SELECT BOOK_ID || TITLE AS BOOK_TITLE, CATEGORY, PRICE, INSERT_DATE, CONTENT
FROM BOOK
DESC PMEMBER

CREATE ON TABLE EMP(


);

/*RECEIPT접수  PATIENT환자  
추가할 것 우편번호 PA_ZIP, 주소 PA_ADD1, PA_ADD2 상세주소, PA_PH 전화번호
*/
/
SELECT   ROWNUM NUM
       , A.PA_NO
       , A.PA_REG
       , A.PA_ZIP
       , A.PA_ADD1
       , A.PA_ADD2
       , A.PA_NAME
       , B.RCP_MEMO
FROM PATIENT A LEFT OUTER JOIN RECEIPT B ON(A.PA_NO = B.PA_NO)
WHERE A.PA_NAME LIKE '%';
/
select 
       B.PA_SEQ, 
       C.DO_NO,
       B.PA_NO,
       B.PA_REG,
       B.PA_NAME,
       A.RCP_MEMO
from  RECEIPT  A LEFT OUTER JOIN PATIENT B ON(A.PA_NO=B.PA_NO)
LEFT OUTER JOIN DOC_OFFICE C ON(A.DO_CODE=C.DO_CODE);
/
SELECT  ROWNUM NUM 
     , A.DOC_NO
     , C.PA_NO
     , C.PA_NAME
     , C.PA_REG
     , C.PA_STATE
     , B.RCP_MEMO
FROM DOC_OFFICE A, Receipt B, Patient C
where A.DOC_CD = B.DOC_CD
AND   B.PA_NO = C.PA_NO
AND A.DOC_NO = '2진료실'
ORDER BY DECODE(C.PA_STATE, '진료중', 1);
/
--진료중 
/
SELECT  ROWNUM NUM 
     , A.DOC_NO
     , C.PA_NO
     , C.PA_NAME
     , C.PA_REG
     , B.RCP_MEMO
FROM DOC_OFFICE A, Receipt B, Patient C
where A.DOC_CD = B.DOC_CD
AND   B.PA_NO = C.PA_NO
AND A.DOC_NO='2진료실'

/


--1) 진료실(doc_office)에 insert(진료실번호, 로그인한직원번호)
SELECT * FROM DOC_OFFICE;

SELECT SUBSTR(MAX(DOC_CD),1,1) || TRIM(TO_CHAR(SUBSTR(NVL(MAX(DOC_CD),'O000'),2) + 1,'000'))
FROM   DOC_OFFICE;

SELECT DO_NO FROM   DOC_OFFICE WHERE DO_NO='1진료실'

INSERT INTO DOC_OFFICE(DOC_NO, EMP_NO) VALUES(
(SELECT DOC_NO FROM DOC_OFFICE WHERE DOC_NO='1진료실'),'D10001'
);

/
INSERT INTO DOC_OFFICE(DOC_CD, EMP_NO, DOC_NO) VALUES(
(SELECT SUBSTR(MAX(DOC_CD),1,1) || TRIM(TO_CHAR(SUBSTR(NVL(MAX(DOC_CD),'D000'),2) + 1,'000'))
FROM   DOC_OFFICE),'D10001', '2진료실'
);
/
--2) 접수(receipt)에 insert(환자번호, 증상메모)
/
INSERT INTO RECEIPT(PA_NO, DOC_CD, RCP_MEMO, RCP_TM, RCP_NO, RCP_FV) VALUES('2022048','O002','장염',SYSDATE,(SELECT NVL(MAX(RCP_NO),0) + 1 FROM RECEIPT));
/
SELECT NVL(MAX(RCP_NO),0) + 1 FROM RECEIPT
/
--신규 환자접수 
/
INSERT INTO PATIENT(PA_NO, PA_REG, PA_NAME, PA_SEX, PA_PH, PA_MAIL, PA_ADD1, PA_ADD2, PA_ZIP,PA_ENDT, PA_ENWT)
VALUES ((SELECT NVL(MAX(PA_NO),0) + 1 FROM PATIENT),	'850902-2******',	'현지',	'남성',	'010-5148-2578','1dasdas@naver.com','대전동구용운동',	'더블룸402',	23415,SYSDATE,'김원무');
/

UPDATE PATIENT
SET   PA_PH='1',PA_ADD1='1',PA_ADD2='1',PA_ZIP=1,PA_UPWT='1'
WHERE PA_NAME ='허지현';
/
UPDATE DOC_OFFICE
SET DOC_STATE='진료중'
WHERE DOC_CD='O003' 
/
    --주문내역 리스트 
	SELECT D.DROR_CD,D.DROR_PRICE,D.DROR_QTY,D.DROR_GUBUN,D.DROR_ORDT,D.IDT_REQ_NUR,D.DR_CD,D.DROR_SEQ,
        S.DSD_NAME,S.DSD_COM, E.EMP_NAME
	    FROM DRUG_ORDER D,DRUG_STOCK_DETAIL S, EMP E
	    WHERE D.DR_CD = S.DR_CD
        AND D.IDT_REQ_NUR = E.EMP_NO
	    ORDER BY DROR_CD ASC
/
		SELECT  ROWNUM NUM
               , D.DROR_CD
               ,D.DROR_PRICE
               ,D.DROR_QTY
               ,D.DROR_GUBUN
               ,D.DROR_ORDT
               ,D.IDT_REQ_NUR
               ,D.DR_CD
               ,D.DROR_SEQ
               ,S.DSD_NAME
               ,S.DSD_COM
               ,E.EMP_NAME
               ,D.DROR_ORDT
   		FROM DRUG_ORDER D,DRUG_STOCK_DETAIL S,EMP E
	    WHERE D.DR_CD = S.DR_CD
	    AND  D.IDT_REQ_NUR = E.EMP_NO
	    order by dror_cd asc
/
--발주 폼 내역 
SELECT 
        ROWNUM NUM
        , A.DI_DT AS 발주일자
        , C.EMP_NAME AS 담당자
        , D.DSD_COM  AS 제조업체 
        , D.DSD_NAME AS 약품명
        , C.EMP_PH  AS 담당자전화번호
FROM DRUG_INDENT A, DRUG_ORDER B , EMP C , DRUG_STOCK_DETAIL D
WHERE  
AND A.IDT_APL_AST = C.EMP_NO;
/

SELECT    A.DI_CD
        , A.DI_DT
        , B.EMP_NAME
        , B.EMP_PH
FROM DRUG_INDENT A , EMP B 
WHERE A.IDT_APL_AST = B.EMP_NO 
--  발주 등록 
/
INSERT
INTO DRUG_INDENT(DI_CD, DI_DT,  IDT_APL_AST )
VALUES((SELECT SUBSTR(MAX(DI_CD),1,1) || TRIM(TO_CHAR(SUBSTR(NVL(MAX(DI_CD),'Z000'),2) + 1,'000'))FROM DRUG_INDENT) 
        ,SYSDATE
        ,'A10001' );
/
-- 발주상세 등록 
INSERT INTO DRUG_DETAIL(DI_CD, DD_NO, DD_QTY, DR_CD)
VALUES((SELECT MAX(DI_CD)FROM DRUG_INDENT), (SELECT NVL(MAX(DD_NO),0) + 1 FROM DRUG_DETAIL), 5, 'MBLONA8');
/
SELECT    A.DD_QTY
        , A.DR_CD
        , B.DI_DT
        , B.DI_CD
        , C.DSD_NAME
        , D.EMP_NAME
        , C.DSD_COM
FROM DRUG_DETAIL A, DRUG_INDENT B, DRUG_STOCK_DETAIL C, EMP D
WHERE A.DI_CD = B.DI_CD
AND A.DR_CD=C.DR_CD
AND  B.IDT_APL_AST = D.EMP_NO 
AND B.DI_CD = 'Z002'
/
--약품주문 삭제
DELETE 
FROM DRUG_ORDER
WHERE DR_CD='MBENZ1'
/
SELECT   B.PA_NO
        ,A.RCP_TM
        ,B.PA_NAME 
        ,A.RCP_MEMO
        ,B.PA_REG
FROM RECEIPT A, PATIENT B
WHERE A.PA_NO =  B.PA_NO
AND A.RCP_TM = '2022-12-08'
/
--제증명 신청
INSERT INTO CERTIFICATE_ORDER(CTF_NO, PR_CD, CTF_GUBUN,  CTF_ENDT, CTF_PAST, CTF_STATE, PA_NAME, EMP_NAME)
VALUES(
        (SELECT NVL(MAX(CTF_NO),0)+1 FROM CERTIFICATE_ORDER)
        ,(SELECT MAX(PR_CD)FROM PRE_RECORD)
        , '소    견서'
        , SYSDATE
        , '서류 제출 때문에 진단서 희망하는 환자입니다'
        , '대기'
        , '김은대'
        , '김현석'
)
/   
--제증명 내역 
SELECT   
          CTF_GUBUN
        , CTF_NAME
        , CTF_ENDT
        , EMP_NAME
        , CTF_STATE
        , PA_NO
FROM CERTIFICATE_ORDER
 WHERE CTF_ENDT BETWEEN TO_DATE('2022-12-01', 'YYYY-MM-DD') 
                   AND TO_DATE(SYSDATE+1)   
AND CTF_GUBUN LIKE '%pres%'
/
SELECT  ROWNUM NUM 
		     , A.DOC_NO
		     , C.PA_NO
		     , C.PA_NAME
		     , C.PA_REG
		     , C.PA_STATE
		     , B.RCP_MEMO
             , B.RCP_TM
		FROM DOC_OFFICE A, Receipt B, Patient C
		where A.DOC_CD = B.DOC_CD
		AND   B.PA_NO = C.PA_NO
		AND A.DOC_NO = '2진료실'
ORDER BY DECODE(C.PA_STATE, '진료중', 1)
, B.RCP_TM ASC

/
--1) 진단서  
SELECT   A.DIS_CD    AS 병명
        ,A.DIA_DT    AS 발병일
        ,A.DIA_ENDT  AS 진단일
        ,A.DIA_USE   AS 용도
        ,A.DIA_CONT  AS 치료의견   
        ,A.CH_DOCNM
        ,B.PA_ADD1
        ,B.PA_SEX
        ,B.PA_NAME 
        ,B.PA_REG
        
FROM DIAGNOSIS A , PATIENT B 
WHERE A.PA_NO = B.PA_NO
AND A.PA_NO = 2022003
AND A.DOCU_CD = 'diag'
/
-- 2) 처방전 

SELECT   A.PRE_SHOT  
        ,A.PRE_CNT 
        ,A.PRE_DAYS 
        ,A.DR_CD  
        ,C.DR_NAME 
        ,B.PA_NAME 
        ,B.PA_REG        
FROM PRESCRIPTION A , PATIENT B , DRUG_API C
WHERE A.PA_NO = B.PA_NO
AND A.DR_CD = C.DR_CD
AND A.PA_NO = 2022045
AND A.DOCU_CD = 'pres'; 

/
--3) 소견서 
SELECT   A.NT_USE 
        ,A.FILE_ATCH_NO 
        ,A.NT_VIEW
        ,A.NT_DT   
        ,B.PA_ADD1
        ,B.PA_SEX
        ,B.PA_NAME 
        ,B.PA_REG
FROM NOTE A , PATIENT B
WHERE A.PA_NO = B.PA_NO
AND A.PA_NO = 2022046
AND A.DOCU_CD = 'note'
/
 SELECT   A.NT_USE 
			   ,A.NT_VIEW
		       ,A.FILE_ATCH_NO         
		       ,B.PA_ADD1
		       ,B.PA_SEX
		       ,B.PA_NAME 
		       ,B.PA_REG
		       ,B.PA_NO
               ,C.EXAM_CD
               ,D.FILE_NAME
		FROM NOTE A , PATIENT B, EXAMINATION C , ATTACH_FILE D
		WHERE A.PA_NO = B.PA_NO
        AND A.PA_NO = C.PA_NO
        AND C.EXAM_CD = D.ANY_CD
		AND A.PA_NO = 	2022016
		AND A.DOCU_CD = 'note'
/
SELECT   A.DIS_CD   
        ,A.DIA_DT   
        ,A.DIA_ENDT 
        ,A.DIA_USE  
        ,A.DIA_CONT 
        ,A.PA_NO
        ,A.DOCU_CD
        ,B.PA_ADD1
        ,B.PA_SEX
        ,B.PA_NAME 
        ,B.PA_REG
FROM DIAGNOSIS A , PATIENT B
WHERE A.PA_NO = B.PA_NO
AND A.PA_NO = 	'2022004' 
AND A.DOCU_CD = 'diag';

SELECT * FROM USER_CONSTRAINTS WHERE CONSTRAINT_NAME='R_33';
/
UPDATE  PATIENT
SET PA_STATE = '대기중'
WHERE PA_NO =2022052;
/
SELECT    PA_NO
		 ,PA_NAME 
		 ,PA_REG
         ,PA_STATE
         ,PA_RES
         ,PA_ADD1
FROM PATIENT 
WHERE PA_STATE = '예약'
AND TO_CHAR(PA_RES, 'YYYY-MM-DD') = '2022-12-30'
/
SELECT  PA_NO PA_NO
		      , PA_REG
		      , PA_NAME
		      , PA_SEX
		      , PA_PH
		      , PA_MAIL
		      , PA_ADD1
		      , PA_ADD2
		      , PA_ZIP
		      , PA_ENDT
		      , PA_ENWT
		      , PA_UPDT
		      , PA_UPWT
		      , PA_TRMR
		      , PA_FIVI_DT
		      , PA_STATE
		      , PA_EXAM_STATE
		FROM PATIENT
        ORDER BY PA_UPDT ASC
/
SELECT PROD_NAME prodName, 
		       SUM(PROD_SALE * CART_QTY) MONEY
		FROM PROD,CART 
		WHERE PROD_ID = CART_PROD
		GROUP BY PROD_NAME
		HAVING SUM(PROD_SALE * CART_QTY) >=10000000
/
SELECT SUM(REC_TOTAL) AS 월별총금액 
FROM RECEIPTION 
WHERE TO_CHAR(REC_DT, 'YYYY-MM') = '2022-12'
/
SELECT EXTRACT (MONTH FROM REC_DT) 
,      SUM(REC_TOTAL) 
FROM RECEIPTION
WHERE EXTRACT (YEAR FROM REC_DT) =2022 
GROUP BY EXTRACT (MONTH FROM REC_DT)
ORDER BY EXTRACT (MONTH FROM REC_DT) ASC;
/
--일일 환자 
SELECT EXTRACT (MONTH FROM PD_TM) 
,      COUNT(PD_NUM) 
FROM PADUMMY
WHERE EXTRACT (YEAR FROM PD_TM) =2022 
GROUP BY EXTRACT (MONTH FROM PD_TM)
ORDER BY EXTRACT (MONTH FROM PD_TM) ASC;
/
SELECT * FROM T
WHERE T.RNUM BETWEEN 1 * 10 -9  AND 1 * 10;
DECLARE
BEGIN
    FOR I IN 54001..5600 LOOP
    INSERT INTO PADUMMY(PD_NUM, PD_TM, PD_NAME) 
    VALUES(I, '2022-12-06','처남');
    END LOOP;
END;
/

SELECT  ROWNUM NUM 
     , A.DOC_NO
     , C.PA_NO
     , C.PA_NAME
     , C.PA_REG
     , C.PA_STATE
     , B.RCP_MEMO
FROM DOC_OFFICE A, Receipt B, Patient C
where A.DOC_CD = B.DOC_CD
AND   B.PA_NO = C.PA_NO
AND A.DOC_NO = '2진료실'
/
SELECT A.PA_NO
,      A.PA_REG
,      A.PA_NAME
,      A.PA_ADD1
,      A.PA_STATE
FROM PATIENT A
WHERE NOT EXISTS(
                    SELECT PA_NO
                    FROM Receipt B
                    WHERE B.PA_NO =A.PA_NO
                )
AND A.PA_STATE = '대기중'
ORDER BY PA_UPDT ASC
/
SELECT   A.NT_USE 
			   ,A.NT_VIEW
		       ,A.FILE_ATCH_NO         
		       ,B.PA_ADD1
		       ,B.PA_SEX
		       ,B.PA_NAME 
		       ,B.PA_REG
		       ,B.PA_NO
               ,C.EXAM_CD
               ,D.FILE_NAME
		FROM NOTE A , PATIENT B, EXAMINATION C , ATTACH_FILE D
		WHERE A.PA_NO = B.PA_NO
        AND A.PA_NO = C.PA_NO
        AND C.EXAM_CD = D.ANY_CD
		AND A.PA_NO = 	2022001   
		AND A.DOCU_CD = 'note'  
/
SELECT A.EXAM_CD, A.EXAM_FEE, A.EXAM_DT, A.EXAM_NAME, A.EXAM_BODPT, B.Pa_No  
FROM EXAMINATION A, TEST_ORDER B
WHERE A.TO_OR_NO = B.TO_OR_NO
AND B.PA_NO = 2022058
ORDER BY A.EXAM_DT DESC
/
SELECT (SELECT COUNT(PA_NAME) FROM PATIENT WHERE PA_TRMR = 'Y')
,       (SELECT COUNT(PA_NAME) FROM PATIENT WHERE PA_TRMR = 'N')
FROM DUAL; 
/
SELECT MAX(RCP_FV)
,      MAX (RCP_ME)
FROM RECEIPT

/
SELECT MAX(RCP_ME)+1
FROM RECEIPT
/
INSERT INTO RECEIPT(PA_NO, DOC_CD, RCP_MEMO, RCP_TM, RCP_NO, RCP_FV) VALUES('2022062','O017','장염',SYSDATE,(SELECT NVL(MAX(RCP_NO),0) + 1 FROM RECEIPT)
,(SELECT MAX(RCP_ME)+1 FROM RECEIPT)
);
/
SELECT  IN_NAME
,       IN_REG
FROM INSURERE
WHERE IN_REG  LIKE '97071%'
/

SELECT   CASE WHEN PA_NAME  IS NULL THEN '널널널'
FROM PATIENT

/
SELECT 
NVL(PA_NAME,'계열사')
FROM PATIENT
WHERE PA_NAME= 'KR';           
            